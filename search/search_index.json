{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Much ado about Loop 2 Mycobacterial Mutagenesis and Drug Resistance Are Controlled by Phosphorylation- and Cardiolipin-Mediated Inhibition of the RecA Coprotease See the Loop 2 tab (left) for information about how the data were generated Read the Mol Cell paper here","title":"Home"},{"location":"#much-ado-about-loop-2","text":"Mycobacterial Mutagenesis and Drug Resistance Are Controlled by Phosphorylation- and Cardiolipin-Mediated Inhibition of the RecA Coprotease See the Loop 2 tab (left) for information about how the data were generated","title":"Much ado about Loop 2"},{"location":"#read-the-mol-cell-paper-here","text":"","title":"Read the Mol Cell paper here"},{"location":"CODE/","text":"Code to query the NCBI database % scReciprocalBLAST --- script to start working from the reciprocal blast % data of recA (MSMEG_2723) and ku (MSMEG_5580). clear, close all; clc; % clears all workspaces basedir = '/Users/Dave/Desktop/recA_ku_orthologSearch/'; % defines the base directory this script uses [MSMEG_5580, locus5580, raw5580] = ... xlsread([basedir 'MSMEG_5580_orthologs.xls']); [MSMEG_2723, locus2723, raw2723] = ... xlsread([basedir 'MSMEG_2723_orthologs.xls']); clear locus2723 locus5580 raw2723 raw5580; % import the data. the two options denoted with locus and raw are % superfluous and therefore deleted MSMEG_2723 = MSMEG_2723(2:end, [9 11]); MSMEG_5580 = MSMEG_5580(2:end, [9 11]); % column 9 contains the taxID for the organisms; column 11 contains the % information about the NCBI gene ID. The first row is % header-information and is superfluous. missingTaxID2723 = find(isnan(MSMEG_2723(:, 1))); missingTaxID5580 = find(isnan(MSMEG_5580(:, 1))); % there are a few genes there there is no taxonomy ID % specified in the file. MSMEG_2723(missingTaxID2723, :) = []; MSMEG_5580(missingTaxID5580, :) = []; % removing all the lines that have no mention of a taxonomy ID clear missingTaxID2723 missingTaxID5580 [C, ia, ib] = intersect(MSMEG_2723, MSMEG_5580); % intersect the data sets to allow identification of only those strains % that have both ku and recA. This is merely to exclude any strains % that, through this way of searching their genomic data, are supposed % to only have ku. ku = MSMEG_5580(ib, :); recAwithKu = MSMEG_2723(ia, :); recAnoKu = MSMEG_2723; recAnoKu(ia, :) = []; % recA = MSMEG_2723; % parse out the data. ku maintains only those records that intersect % with recA, so those organisms have recA. Then there are three sets of % recA data: the full set (recA), the intersect with ku (recAwithKu) % and any recA that does not intersect with ku (recAnoKu). clear C ia ib MSMEG_2723 MSMEG_5580; %% QUERY NC baseURL = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=protein id='; restURL = ' rettype=fasta retmode=text'; % part FOUR of the URL to query, returning the accession codes % NOTE: the URL to submit for the query will consist of the base % URL, followed by the accID part, then the GI numbers with commas % in between them, and finished by rettype. % samples2search = 1:length(recAnoKu); GInumbers = sprintf('%d,', recAnoKu(1:400, 2)); GInumbers = char(GInumbers(1:end-1)); searchValue = strcat(baseURL, GInumbers, restURL); % k = websave([basedir 'recAnoKu_protein.fasta'], searchValue); clear k Reciprocal BLAST of the RecA and Ku % scReciprocalBLAST --- script to start working from the reciprocal blast % data of recA (MSMEG_2723) and ku (MSMEG_5580). clear, close all; clc; % clears all workspaces basedir = '/Users/Dave/Desktop/recA_ku_orthologSearch/'; % defines the base directory this script uses [MSMEG_5580, locus5580, raw5580] = ... xlsread([basedir 'MSMEG_5580_orthologs.xls']); [MSMEG_2723, locus2723, raw2723] = ... xlsread([basedir 'MSMEG_2723_orthologs.xls']); clear locus2723 locus5580 raw2723 raw5580; % import the data. the two options denoted with locus and raw are % superfluous and therefore deleted MSMEG_2723 = MSMEG_2723(2:end, [9 11]); MSMEG_5580 = MSMEG_5580(2:end, [9 11]); % column 9 contains the taxID for the organisms; column 11 contains the % information about the NCBI gene ID. The first row is % header-information and is superfluous. missingTaxID2723 = find(isnan(MSMEG_2723(:, 1))); missingTaxID5580 = find(isnan(MSMEG_5580(:, 1))); % there are a few genes there there is no taxonomy ID % specified in the file. MSMEG_2723(missingTaxID2723, :) = []; MSMEG_5580(missingTaxID5580, :) = []; % removing all the lines that have no mention of a taxonomy ID clear missingTaxID2723 missingTaxID5580 [C, ia, ib] = intersect(MSMEG_2723, MSMEG_5580); % intersect the data sets to allow identification of only those strains % that have both ku and recA. This is merely to exclude any strains % that, through this way of searching their genomic data, are supposed % to only have ku. ku = MSMEG_5580(ib, :); recAwithKu = MSMEG_2723(ia, :); recAnoKu = MSMEG_2723; recAnoKu(ia, :) = []; recA = MSMEG_2723; % parse out the data. ku maintains only those records that intersect % with recA, so those organisms have recA. Then there are three sets of % recA data: the full set (recA), the intersect with ku (recAwithKu) % and any recA that does not intersect with ku (recAnoKu). clear C ia ib MSMEG_2723 MSMEG_5580; %% QUERY KEGG FOR GENE IDS --- TIME CONSUMING!! base = 'http://rest.kegg.jp/'; operation = 'conv/'; database = 'genes/'; dbentry = 'ncbi-gi:'; %% kegg_ku = cell(length(ku), 1); for i = 1:length(ku) dbentry1 = strcat(dbentry, num2str(ku(i, 2))); kegg_ku{i} = regexpi(urlread(strcat(base, operation, database,... dbentry1)), '(? =(??@dbentry1)\\s+)\\w+\\W+\\w*','match'); end; clear i %% kegg_recAnoKu = cell(length(recAnoKu), 1); for i = 1:length(recAnoKu) dbentry1 = strcat(dbentry, num2str(recAnoKu(i, 2))); kegg_recAnoKu{i} = regexpi(urlread(strcat(base, operation, database,... dbentry1)), '(? =(??@dbentry1)\\s+)\\w+\\W+\\w*','match'); end; clear i %% kegg_recAwithKu = cell(length(recAwithKu), 1); for i = 1:length(recAwithKu) dbentry1 = strcat(dbentry, num2str(recAwithKu(i, 2))); kegg_recAwithKu{i} = regexpi(urlread(strcat(base, operation, database,... dbentry1)), '(? =(??@dbentry1)\\s+)\\w+\\W+\\w*','match'); end; clear i %% QUERY KEGG FOR KU GENE SEQUENCES base = 'http://rest.kegg.jp/'; operation = 'get/'; option = 'ntseq'; %% emptyKu = find(cellfun(@isempty,kegg_ku)); kegg_ku(emptyKu) = []; % remove all the genes that did not give any hits in KEGG. for i = 1:length(kegg_ku) kuSeq = urlread(char(strcat(base, operation, kegg_ku{i}, '/', option))); headerFind = findstr(') atg', kuSeq); if numel(headerFind) == 0 headerFind = findstr(') gtg', kuSeq); elseif numel(headerFind) == 0 headerFind = findstr(') ctg', kuSeq); elseif numel(headerFind) == 0 headerFind = findstr(') ttg', kuSeq); end sequenceData = kuSeq(headerFind(1):end); fastawrite([basedir 'kuSeq.fasta'], kegg_ku{i},... sequenceData); end; clear i %% emptyRecAnoKu = find(cellfun(@isempty,kegg_recAnoKu)); kegg_recAnoKu(emptyRecAnoKu) = []; % remove all the genes that did not give any hits in KEGG. for i = 1:length(kegg_recAnoKu) recAnoKuSeq = urlread(char(strcat(base, operation,... kegg_recAnoKu{i}, '/', option))); headerFind = findstr('atg', recAnoKuSeq); if numel(headerFind) == 0 headerFind = findstr('gtg', recAnoKuSeq); end sequenceData = recAnoKuSeq(headerFind(1):end); fastawrite([basedir 'recAnoKuSeq.fasta'], kegg_recAnoKu{i},... sequenceData); end; clear i %% emptyRecAwithKu = find(cellfun(@isempty,kegg_recAwithKu)); kegg_recAwithKu(emptyRecAwithKu) = []; % remove all the genes that did not give any hits in KEGG. for i = 1:length(kegg_recAwithKu) recAwithKuSeq = urlread(char(strcat(base, operation,... kegg_recAwithKu{i}, '/', option))); headerFind = findstr('atg', recAwithKuSeq); if numel(headerFind) == 0 headerFind = findstr('gtg', recAwithKuSeq); end sequenceData = recAwithKuSeq(headerFind(1):end); fastawrite([basedir 'recAwithKuSeq.fasta'], kegg_recAwithKu{i},... sequenceData); end; clear i Cluster and calculate pairwise distances % scClusteringPairwiseDistances --- this script will plot the dendrogram % for the pairwise distance information that Matt obtained for the recA % sequences. clc; clear, close all; basedir = '/Users/Dave/Desktop/recA_ku_orthologSearch/pairwiseDistance/'; % define the base directory distanceMatrix = importdata([basedir '151202.csv']); distanceMatrix.textdata = distanceMatrix.textdata(2:end, 1:2); % import the data attributes = importdata([basedir 'attributeTable.xlsx']); attributes.AttributeFile = attributes.AttributeFile(2:end, :); % import the attribute file. Only 'AttributeFile' is of importance. % %% THIS IS TO CREATE THE CLUSTERGRAM FROM THE DATA % distanceMatrix.data = flipud(distanceMatrix.data); % distanceMatrix.textdata = flipud(distanceMatrix.textdata); % % data flipped upside down % % data4clustering = squareform(distanceMatrix.data(:, 1)); % % make the data into a square matrix for clustering % CGobj = clustergram(data4clustering); % % standard clustergram, making an object that is not easily manipulated %% ATEMPT TO RECREATE THE DENDROGRAM USING LINKAGE AND DENDROGRAM COMMANDS distanceMatrix.data = flipud(distanceMatrix.data); distanceMatrix.textdata = flipud(distanceMatrix.textdata); % data flipped upside down; this is done to get out the proper format % for creating the squareform matrix downstream. it also means that all % subsequent data will need to be reorganized. labels = flipud(unique(distanceMatrix.textdata)); % try to get the labels out for the tree and flip for compatibility data4clustering = squareform(distanceMatrix.data(:, 1)); % make the data into a square matrix for clustering attributes.AttributeFile = flipud(sortrows(attributes.AttributeFile, 1)); % alphabetically order the attribute file and flip upside down to be % compatible with the rest of the data NHEJ = strfind(attributes.AttributeFile(:, 2), 'NHEJ'); % denote all NHEJ organisms with 1 NHEJ = ~cellfun(@isempty, NHEJ); % replace all empty cells with 0 NHEJ = repmat(NHEJ, 1, 50); res207 = NaN(length(attributes.AttributeFile), 1); for i = 1:length(attributes.AttributeFile) if strcmp('S', attributes.AttributeFile(i, 3)) == 1; res207(i, 1) = 0; elseif strcmp('N', attributes.AttributeFile(i, 3)) == 1; res207(i, 1) = 1; else res207(i, 1) = 2; end end; clear i % create a vector with different values depending on what is considered % residue 207 (S, N, or other). res207 = repmat(res207, 1, 50); tree = linkage(data4clustering, 'average', 'euclidean'); % make the data for the tree. The tree will be made in the exact same % fashion as the standard clustergram dendrogram is made. This means % 'average' linkage and 'euclidian' distance metric. leafOrder = optimalleaforder(tree, data4clustering); % optimize the leaf order. %% figure; subplot (20, 1, 1:8 ) dendrogram(tree, 0, 'Labels', [], 'Reorder', leafOrder,... 'colorthreshold', 75); ax = gca; % ax.XTickLabelRotation = 90; % make sure the labels are rotated set(gca, 'YTick', [], 'XTick', [], 'Box', 'off', 'Color', 'none'); axis off; h = subplot (20, 1, 9:18); imagesc(data4clustering(leafOrder, leafOrder)); set(gca, 'YTick', [], 'XTick', [], 'Color', 'none'); colormap(h, jet); i = subplot (20, 1, 19); imagesc(NHEJ(leafOrder)) set(gca, 'YTick', [], 'XTick', [], 'Color', 'none'); colormap(i, gray); j = subplot (20, 1, 20); imagesc(res207(leafOrder)) set(gca, 'YTick', [], 'XTick', [], 'Color', 'none'); colormap(j, parula); clear h i j %% N = 0; NKu = 0; S = 0; SKu = 0; for i = 1:length(attributes.AttributeFile) if strcmp(attributes.AttributeFile(i, 3), 'N') ... strcmp(attributes.AttributeFile(i, 2), 'NHEJ') NKu = NKu + 1; end if strcmp(attributes.AttributeFile(i, 3), 'N') N = N + 1; end if strcmp(attributes.AttributeFile(i, 3), 'S') ... strcmp(attributes.AttributeFile(i, 2), 'NHEJ') SKu = SKu + 1; end if strcmp(attributes.AttributeFile(i, 3), 'S') S = S + 1; end end; clear i","title":"Code"},{"location":"CODE/#code-to-query-the-ncbi-database","text":"% scReciprocalBLAST --- script to start working from the reciprocal blast % data of recA (MSMEG_2723) and ku (MSMEG_5580). clear, close all; clc; % clears all workspaces basedir = '/Users/Dave/Desktop/recA_ku_orthologSearch/'; % defines the base directory this script uses [MSMEG_5580, locus5580, raw5580] = ... xlsread([basedir 'MSMEG_5580_orthologs.xls']); [MSMEG_2723, locus2723, raw2723] = ... xlsread([basedir 'MSMEG_2723_orthologs.xls']); clear locus2723 locus5580 raw2723 raw5580; % import the data. the two options denoted with locus and raw are % superfluous and therefore deleted MSMEG_2723 = MSMEG_2723(2:end, [9 11]); MSMEG_5580 = MSMEG_5580(2:end, [9 11]); % column 9 contains the taxID for the organisms; column 11 contains the % information about the NCBI gene ID. The first row is % header-information and is superfluous. missingTaxID2723 = find(isnan(MSMEG_2723(:, 1))); missingTaxID5580 = find(isnan(MSMEG_5580(:, 1))); % there are a few genes there there is no taxonomy ID % specified in the file. MSMEG_2723(missingTaxID2723, :) = []; MSMEG_5580(missingTaxID5580, :) = []; % removing all the lines that have no mention of a taxonomy ID clear missingTaxID2723 missingTaxID5580 [C, ia, ib] = intersect(MSMEG_2723, MSMEG_5580); % intersect the data sets to allow identification of only those strains % that have both ku and recA. This is merely to exclude any strains % that, through this way of searching their genomic data, are supposed % to only have ku. ku = MSMEG_5580(ib, :); recAwithKu = MSMEG_2723(ia, :); recAnoKu = MSMEG_2723; recAnoKu(ia, :) = []; % recA = MSMEG_2723; % parse out the data. ku maintains only those records that intersect % with recA, so those organisms have recA. Then there are three sets of % recA data: the full set (recA), the intersect with ku (recAwithKu) % and any recA that does not intersect with ku (recAnoKu). clear C ia ib MSMEG_2723 MSMEG_5580; %% QUERY NC baseURL = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=protein id='; restURL = ' rettype=fasta retmode=text'; % part FOUR of the URL to query, returning the accession codes % NOTE: the URL to submit for the query will consist of the base % URL, followed by the accID part, then the GI numbers with commas % in between them, and finished by rettype. % samples2search = 1:length(recAnoKu); GInumbers = sprintf('%d,', recAnoKu(1:400, 2)); GInumbers = char(GInumbers(1:end-1)); searchValue = strcat(baseURL, GInumbers, restURL); % k = websave([basedir 'recAnoKu_protein.fasta'], searchValue); clear k","title":"Code to query the NCBI database"},{"location":"CODE/#reciprocal-blast-of-the-reca-and-ku","text":"% scReciprocalBLAST --- script to start working from the reciprocal blast % data of recA (MSMEG_2723) and ku (MSMEG_5580). clear, close all; clc; % clears all workspaces basedir = '/Users/Dave/Desktop/recA_ku_orthologSearch/'; % defines the base directory this script uses [MSMEG_5580, locus5580, raw5580] = ... xlsread([basedir 'MSMEG_5580_orthologs.xls']); [MSMEG_2723, locus2723, raw2723] = ... xlsread([basedir 'MSMEG_2723_orthologs.xls']); clear locus2723 locus5580 raw2723 raw5580; % import the data. the two options denoted with locus and raw are % superfluous and therefore deleted MSMEG_2723 = MSMEG_2723(2:end, [9 11]); MSMEG_5580 = MSMEG_5580(2:end, [9 11]); % column 9 contains the taxID for the organisms; column 11 contains the % information about the NCBI gene ID. The first row is % header-information and is superfluous. missingTaxID2723 = find(isnan(MSMEG_2723(:, 1))); missingTaxID5580 = find(isnan(MSMEG_5580(:, 1))); % there are a few genes there there is no taxonomy ID % specified in the file. MSMEG_2723(missingTaxID2723, :) = []; MSMEG_5580(missingTaxID5580, :) = []; % removing all the lines that have no mention of a taxonomy ID clear missingTaxID2723 missingTaxID5580 [C, ia, ib] = intersect(MSMEG_2723, MSMEG_5580); % intersect the data sets to allow identification of only those strains % that have both ku and recA. This is merely to exclude any strains % that, through this way of searching their genomic data, are supposed % to only have ku. ku = MSMEG_5580(ib, :); recAwithKu = MSMEG_2723(ia, :); recAnoKu = MSMEG_2723; recAnoKu(ia, :) = []; recA = MSMEG_2723; % parse out the data. ku maintains only those records that intersect % with recA, so those organisms have recA. Then there are three sets of % recA data: the full set (recA), the intersect with ku (recAwithKu) % and any recA that does not intersect with ku (recAnoKu). clear C ia ib MSMEG_2723 MSMEG_5580; %% QUERY KEGG FOR GENE IDS --- TIME CONSUMING!! base = 'http://rest.kegg.jp/'; operation = 'conv/'; database = 'genes/'; dbentry = 'ncbi-gi:'; %% kegg_ku = cell(length(ku), 1); for i = 1:length(ku) dbentry1 = strcat(dbentry, num2str(ku(i, 2))); kegg_ku{i} = regexpi(urlread(strcat(base, operation, database,... dbentry1)), '(? =(??@dbentry1)\\s+)\\w+\\W+\\w*','match'); end; clear i %% kegg_recAnoKu = cell(length(recAnoKu), 1); for i = 1:length(recAnoKu) dbentry1 = strcat(dbentry, num2str(recAnoKu(i, 2))); kegg_recAnoKu{i} = regexpi(urlread(strcat(base, operation, database,... dbentry1)), '(? =(??@dbentry1)\\s+)\\w+\\W+\\w*','match'); end; clear i %% kegg_recAwithKu = cell(length(recAwithKu), 1); for i = 1:length(recAwithKu) dbentry1 = strcat(dbentry, num2str(recAwithKu(i, 2))); kegg_recAwithKu{i} = regexpi(urlread(strcat(base, operation, database,... dbentry1)), '(? =(??@dbentry1)\\s+)\\w+\\W+\\w*','match'); end; clear i %% QUERY KEGG FOR KU GENE SEQUENCES base = 'http://rest.kegg.jp/'; operation = 'get/'; option = 'ntseq'; %% emptyKu = find(cellfun(@isempty,kegg_ku)); kegg_ku(emptyKu) = []; % remove all the genes that did not give any hits in KEGG. for i = 1:length(kegg_ku) kuSeq = urlread(char(strcat(base, operation, kegg_ku{i}, '/', option))); headerFind = findstr(') atg', kuSeq); if numel(headerFind) == 0 headerFind = findstr(') gtg', kuSeq); elseif numel(headerFind) == 0 headerFind = findstr(') ctg', kuSeq); elseif numel(headerFind) == 0 headerFind = findstr(') ttg', kuSeq); end sequenceData = kuSeq(headerFind(1):end); fastawrite([basedir 'kuSeq.fasta'], kegg_ku{i},... sequenceData); end; clear i %% emptyRecAnoKu = find(cellfun(@isempty,kegg_recAnoKu)); kegg_recAnoKu(emptyRecAnoKu) = []; % remove all the genes that did not give any hits in KEGG. for i = 1:length(kegg_recAnoKu) recAnoKuSeq = urlread(char(strcat(base, operation,... kegg_recAnoKu{i}, '/', option))); headerFind = findstr('atg', recAnoKuSeq); if numel(headerFind) == 0 headerFind = findstr('gtg', recAnoKuSeq); end sequenceData = recAnoKuSeq(headerFind(1):end); fastawrite([basedir 'recAnoKuSeq.fasta'], kegg_recAnoKu{i},... sequenceData); end; clear i %% emptyRecAwithKu = find(cellfun(@isempty,kegg_recAwithKu)); kegg_recAwithKu(emptyRecAwithKu) = []; % remove all the genes that did not give any hits in KEGG. for i = 1:length(kegg_recAwithKu) recAwithKuSeq = urlread(char(strcat(base, operation,... kegg_recAwithKu{i}, '/', option))); headerFind = findstr('atg', recAwithKuSeq); if numel(headerFind) == 0 headerFind = findstr('gtg', recAwithKuSeq); end sequenceData = recAwithKuSeq(headerFind(1):end); fastawrite([basedir 'recAwithKuSeq.fasta'], kegg_recAwithKu{i},... sequenceData); end; clear i","title":"Reciprocal BLAST of the RecA and Ku"},{"location":"CODE/#cluster-and-calculate-pairwise-distances","text":"% scClusteringPairwiseDistances --- this script will plot the dendrogram % for the pairwise distance information that Matt obtained for the recA % sequences. clc; clear, close all; basedir = '/Users/Dave/Desktop/recA_ku_orthologSearch/pairwiseDistance/'; % define the base directory distanceMatrix = importdata([basedir '151202.csv']); distanceMatrix.textdata = distanceMatrix.textdata(2:end, 1:2); % import the data attributes = importdata([basedir 'attributeTable.xlsx']); attributes.AttributeFile = attributes.AttributeFile(2:end, :); % import the attribute file. Only 'AttributeFile' is of importance. % %% THIS IS TO CREATE THE CLUSTERGRAM FROM THE DATA % distanceMatrix.data = flipud(distanceMatrix.data); % distanceMatrix.textdata = flipud(distanceMatrix.textdata); % % data flipped upside down % % data4clustering = squareform(distanceMatrix.data(:, 1)); % % make the data into a square matrix for clustering % CGobj = clustergram(data4clustering); % % standard clustergram, making an object that is not easily manipulated %% ATEMPT TO RECREATE THE DENDROGRAM USING LINKAGE AND DENDROGRAM COMMANDS distanceMatrix.data = flipud(distanceMatrix.data); distanceMatrix.textdata = flipud(distanceMatrix.textdata); % data flipped upside down; this is done to get out the proper format % for creating the squareform matrix downstream. it also means that all % subsequent data will need to be reorganized. labels = flipud(unique(distanceMatrix.textdata)); % try to get the labels out for the tree and flip for compatibility data4clustering = squareform(distanceMatrix.data(:, 1)); % make the data into a square matrix for clustering attributes.AttributeFile = flipud(sortrows(attributes.AttributeFile, 1)); % alphabetically order the attribute file and flip upside down to be % compatible with the rest of the data NHEJ = strfind(attributes.AttributeFile(:, 2), 'NHEJ'); % denote all NHEJ organisms with 1 NHEJ = ~cellfun(@isempty, NHEJ); % replace all empty cells with 0 NHEJ = repmat(NHEJ, 1, 50); res207 = NaN(length(attributes.AttributeFile), 1); for i = 1:length(attributes.AttributeFile) if strcmp('S', attributes.AttributeFile(i, 3)) == 1; res207(i, 1) = 0; elseif strcmp('N', attributes.AttributeFile(i, 3)) == 1; res207(i, 1) = 1; else res207(i, 1) = 2; end end; clear i % create a vector with different values depending on what is considered % residue 207 (S, N, or other). res207 = repmat(res207, 1, 50); tree = linkage(data4clustering, 'average', 'euclidean'); % make the data for the tree. The tree will be made in the exact same % fashion as the standard clustergram dendrogram is made. This means % 'average' linkage and 'euclidian' distance metric. leafOrder = optimalleaforder(tree, data4clustering); % optimize the leaf order. %% figure; subplot (20, 1, 1:8 ) dendrogram(tree, 0, 'Labels', [], 'Reorder', leafOrder,... 'colorthreshold', 75); ax = gca; % ax.XTickLabelRotation = 90; % make sure the labels are rotated set(gca, 'YTick', [], 'XTick', [], 'Box', 'off', 'Color', 'none'); axis off; h = subplot (20, 1, 9:18); imagesc(data4clustering(leafOrder, leafOrder)); set(gca, 'YTick', [], 'XTick', [], 'Color', 'none'); colormap(h, jet); i = subplot (20, 1, 19); imagesc(NHEJ(leafOrder)) set(gca, 'YTick', [], 'XTick', [], 'Color', 'none'); colormap(i, gray); j = subplot (20, 1, 20); imagesc(res207(leafOrder)) set(gca, 'YTick', [], 'XTick', [], 'Color', 'none'); colormap(j, parula); clear h i j %% N = 0; NKu = 0; S = 0; SKu = 0; for i = 1:length(attributes.AttributeFile) if strcmp(attributes.AttributeFile(i, 3), 'N') ... strcmp(attributes.AttributeFile(i, 2), 'NHEJ') NKu = NKu + 1; end if strcmp(attributes.AttributeFile(i, 3), 'N') N = N + 1; end if strcmp(attributes.AttributeFile(i, 3), 'S') ... strcmp(attributes.AttributeFile(i, 2), 'NHEJ') SKu = SKu + 1; end if strcmp(attributes.AttributeFile(i, 3), 'S') S = S + 1; end end; clear i","title":"Cluster and calculate pairwise distances"},{"location":"Loop2/","text":"RecA S207 Loop2 analysis Finding orthologs Orthologous genes of M. smegmatis RecA (MSMEG_2723) were obtained through OrtholugeDB, which uses a reciprocal BLAST-based algorithm to ensure validity of the orthologous sequences. Briefly, the top BLAST results from an initial search are BLASTed back against the original reference genome, and the results are only counted as orthologs if the top hit in this second search corresponds to the initial sequence of interest. This approach was applied to both recA and ku. All reciprocal Ortholuge results lacking a taxonomy ID (yielding it impossible to identify the species of origin bioinformatically) were disregarded. The recA and ku databases were subsequently intersected. Organisms that had both recA and ku coding sequences were considered capable of NHEJ; all others were considered to be capable only of HR. Using taxonomy IDs the KEGG database was then queried for recA protein-coding nucleotide sequences. Additionally, we used BLAST and OrtholugeDB to look for organisms that contained Ku, a unique marker of NHEJ in bacteria and archea. This list of organisms was compared with the list of RecA orthologs, and was used to extrapolate whether or not organisms rely solely on HR for DNA repair, or also have NHEJ. In order to account for both synonymous and non-synonymous mutations, nucleotide sequences for all organisms were translated into protein sequences, then aligned by Muscle, and finally re-translated back to nucleotide sequences using MEGA6. This multiple alignment was used to test 24 nucleotide substitution models, and the model with the lowest Bayesian information criterion (BIC) score was chosen for computing the pairwise evolutionary distances between each sequence\u2014the general time reversible (GTR) model with a gamma distributed substitution rate (\u0393) and an allowance for a proportion of invariant sites (I). The number of base substitutions per site between sequences were used to represent the relative evolutionary distance. Analyses were conducted using the Maximum Composite Likelihood model [1]. The rate variation among sites was modeled with a gamma distribution (shape parameter = 1). The analysis involved 1293 nucleotide sequences. All codon positions were included. All ambiguous positions were removed for each sequence pair. There were a total of 6264 positions in the final dataset. Evolutionary analyses were conducted in MEGA6. All organisms in the final database were annotated for NHEJ or HR (as mentioned previously), as well as for their amino acid residue corresponding to residue 207 in Msmeg. Using Matlab, a leaf-optimized dendrogram was created using the linkage function from the Statistics Toolbox. For the linkage, \u2018average\u2019 (unweighted average distance) was used as the metric, and the Euclidean distance was utilized as the distance metric. The evolutionary distance matrix was outputted as a heatmap, and two bars were created to indicate the respective DNA repair pathway the organisms presumably possess, as well as the particular residue at the relative position of 207. See figure for results. 128/787 organisms with RecA-N207 were capable of NHEJ, whereas 146/436 organisms with RecA-S207 were capable of NHEJ (Chi-square test: p 0.001). Figure Figure: Bioinformatics results suggest that RecA-S207 is correlated with an organism\u2019s capacity to perform NHEJ. At the top of the figure is the dendrogram, based on the evolutionary pairwise distances (second panel: more yellow equals more distant, darker blue equals less distant) calculated from the nucleotide sequences of recA. The third panel denotes the organism\u2019s capacity to perform NHEJ as judged by the presence of ku in their genome. White denotes that the bacterium is capable of NHEJ (to be changed!!) and black denotes an organism can only perform HR. The lowest panel denotes the respective residue at position 207 (as compared to the Msmeg sequence). Citations OrtholugeDB: Whiteside MD, Winsor GL, Laird MR, Brinkman FS. OrtholugeDB: a bacterial and archaeal orthology resource for improved comparative genomic analysis. Nucleic Acids Research. 2013 Jan;41(Database issue):D366-76. KEGG: Kanehisa, M., Goto, S. (2000). KEGG: kyoto encyclopedia of genes and genomes. Nucleic Acids Res. 2000 Jan 1;28(1):27-30. Pairwise distance method: Tamura K., Nei M., and Kumar S. (2004). Prospects for inferring very large phylogenies by using the neighbor-joining method. Proceedings of the National Academy of Sciences (USA) 101:11030-11035. MEGA6: Tamura K., Stecher G., Peterson D., Filipski A., and Kumar S. (2013). MEGA6: Molecular Evolutionary Genetics Analysis version 6.0. Molecular Biology and Evolution30: 2725-2729.","title":"Loop2"},{"location":"Loop2/#reca-s207-loop2-analysis","text":"","title":"RecA S207 Loop2 analysis"},{"location":"Loop2/#finding-orthologs","text":"Orthologous genes of M. smegmatis RecA (MSMEG_2723) were obtained through OrtholugeDB, which uses a reciprocal BLAST-based algorithm to ensure validity of the orthologous sequences. Briefly, the top BLAST results from an initial search are BLASTed back against the original reference genome, and the results are only counted as orthologs if the top hit in this second search corresponds to the initial sequence of interest. This approach was applied to both recA and ku. All reciprocal Ortholuge results lacking a taxonomy ID (yielding it impossible to identify the species of origin bioinformatically) were disregarded. The recA and ku databases were subsequently intersected. Organisms that had both recA and ku coding sequences were considered capable of NHEJ; all others were considered to be capable only of HR. Using taxonomy IDs the KEGG database was then queried for recA protein-coding nucleotide sequences. Additionally, we used BLAST and OrtholugeDB to look for organisms that contained Ku, a unique marker of NHEJ in bacteria and archea. This list of organisms was compared with the list of RecA orthologs, and was used to extrapolate whether or not organisms rely solely on HR for DNA repair, or also have NHEJ. In order to account for both synonymous and non-synonymous mutations, nucleotide sequences for all organisms were translated into protein sequences, then aligned by Muscle, and finally re-translated back to nucleotide sequences using MEGA6. This multiple alignment was used to test 24 nucleotide substitution models, and the model with the lowest Bayesian information criterion (BIC) score was chosen for computing the pairwise evolutionary distances between each sequence\u2014the general time reversible (GTR) model with a gamma distributed substitution rate (\u0393) and an allowance for a proportion of invariant sites (I). The number of base substitutions per site between sequences were used to represent the relative evolutionary distance. Analyses were conducted using the Maximum Composite Likelihood model [1]. The rate variation among sites was modeled with a gamma distribution (shape parameter = 1). The analysis involved 1293 nucleotide sequences. All codon positions were included. All ambiguous positions were removed for each sequence pair. There were a total of 6264 positions in the final dataset. Evolutionary analyses were conducted in MEGA6. All organisms in the final database were annotated for NHEJ or HR (as mentioned previously), as well as for their amino acid residue corresponding to residue 207 in Msmeg. Using Matlab, a leaf-optimized dendrogram was created using the linkage function from the Statistics Toolbox. For the linkage, \u2018average\u2019 (unweighted average distance) was used as the metric, and the Euclidean distance was utilized as the distance metric. The evolutionary distance matrix was outputted as a heatmap, and two bars were created to indicate the respective DNA repair pathway the organisms presumably possess, as well as the particular residue at the relative position of 207. See figure for results. 128/787 organisms with RecA-N207 were capable of NHEJ, whereas 146/436 organisms with RecA-S207 were capable of NHEJ (Chi-square test: p 0.001).","title":"Finding orthologs"},{"location":"Loop2/#figure","text":"Figure: Bioinformatics results suggest that RecA-S207 is correlated with an organism\u2019s capacity to perform NHEJ. At the top of the figure is the dendrogram, based on the evolutionary pairwise distances (second panel: more yellow equals more distant, darker blue equals less distant) calculated from the nucleotide sequences of recA. The third panel denotes the organism\u2019s capacity to perform NHEJ as judged by the presence of ku in their genome. White denotes that the bacterium is capable of NHEJ (to be changed!!) and black denotes an organism can only perform HR. The lowest panel denotes the respective residue at position 207 (as compared to the Msmeg sequence).","title":"Figure"},{"location":"Loop2/#citations","text":"OrtholugeDB: Whiteside MD, Winsor GL, Laird MR, Brinkman FS. OrtholugeDB: a bacterial and archaeal orthology resource for improved comparative genomic analysis. Nucleic Acids Research. 2013 Jan;41(Database issue):D366-76. KEGG: Kanehisa, M., Goto, S. (2000). KEGG: kyoto encyclopedia of genes and genomes. Nucleic Acids Res. 2000 Jan 1;28(1):27-30. Pairwise distance method: Tamura K., Nei M., and Kumar S. (2004). Prospects for inferring very large phylogenies by using the neighbor-joining method. Proceedings of the National Academy of Sciences (USA) 101:11030-11035. MEGA6: Tamura K., Stecher G., Peterson D., Filipski A., and Kumar S. (2013). MEGA6: Molecular Evolutionary Genetics Analysis version 6.0. Molecular Biology and Evolution30: 2725-2729.","title":"Citations"}]}